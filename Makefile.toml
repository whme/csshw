#
#  ASCII Art: https://patorjk.com/software/taag/#p=display&f=Pagga
#

[config]
default_to_workspace = false

######################################################################################
# ░█▀▄░█▀▀░█▀█░█▀▄░█▄█░█▀▀░░░░░█▀▀░█░░░▀█▀░░░░░█░█░█▀▀░█░░░█▀█░░░▀█▀░█▀█░█▀▀░█░█░█▀▀ #
# ░█▀▄░█▀▀░█▀█░█░█░█░█░█▀▀░▄▄▄░█░░░█░░░░█░░▄▄▄░█▀█░█▀▀░█░░░█▀▀░░░░█░░█▀█░▀▀█░█▀▄░▀▀█ #
# ░▀░▀░▀▀▀░▀░▀░▀▀░░▀░▀░▀▀▀░░░░░▀▀▀░▀▀▀░▀▀▀░░░░░▀░▀░▀▀▀░▀▀▀░▀░░░░░░▀░░▀░▀░▀▀▀░▀░▀░▀▀▀ #
######################################################################################

# We're on Windows, use \r\n line endings

[tasks.check-readme-help]
# Task used to check whether the help section of the README.md matches the current `--help` output.
# As the underlying task creates temporary files a cleanup task is defined to delete them afterwards.
run_task = { name = [
    "check-readme-help-task",
], fork = true, cleanup_task = "process-readme-help-cleanup" }

[tasks.process-readme-help-cleanup]
private = true
description = "Remove temporary files created by the process-readme-help task"
command = "CMD"
args = [
    "/C",
    "DEL /F /Q .\\.help.tmp .\\.readme-help.tmp .\\.readme-content.tmp .\\.positions.tmp 2>nul",
]

[tasks.process-readme-help]
private = true
description = "Shared logic to process README help section and current --help output"
script_runner = "@duckscript"
script = '''
# Get current help output
# Sadly we have to redirect the output to a temporary file here
# as duckscript does not support capturing stdout here
exec "cmd" "/c" "cargo run -- --help > .help.tmp"
actual_help = readfile .help.tmp

# Preprocess actual_help to clean lines with only spaces
# Split into lines, process each line, then rejoin
# We split \n here because "empty" lines only uses \n
lines = split ${actual_help} "\n"
processed_lines = array
for line in ${lines}
    # Trim the line to check if it contains only whitespace
    trimmed_line = trim ${line}
    if is_empty ${trimmed_line}
        # If line contains only whitespace, replace with empty line
        array_push ${processed_lines} ""
    else
        # Keep the original line (preserving indentation)
        array_push ${processed_lines} ${line}
    end
end
actual_help = array_join ${processed_lines} "\r\n"
actual_help = trim ${actual_help}
# Write the processed lines back to the tmp file for later use
writefile .help.tmp ${actual_help}

# Read README.md content
readme_content = readfile README.md

# Check if delimiters exist
start_marker = set "<!-- HELP_OUTPUT_START -->"
end_marker = set "<!-- HELP_OUTPUT_END -->"

start_index = indexof ${readme_content} ${start_marker}
end_index = indexof ${readme_content} ${end_marker}

if equals ${start_index} -1
    exec "powershell" "-Command" "Write-Host -NoNewline -ForegroundColor Red 'ERROR'; Write-Host ' - Could not find <!-- HELP_OUTPUT_START --> delimiter in README.md'"
    exit 1
end

if equals ${end_index} -1
    exec "powershell" "-Command" "Write-Host -NoNewline -ForegroundColor Red 'ERROR'; Write-Host ' - Could not find <!-- HELP_OUTPUT_END --> delimiter in README.md'"
    exit 1
end

# Calculate character offsets to skip unwanted content

start_marker_len = length ${start_marker}
skip_content = set "\r\n```cmd\r\ncsshw.exe --help\r\n"
skip_content_len = length ${skip_content}
help_start_pos = calc ${start_index} + ${start_marker_len} + ${skip_content_len}

# For end skip: \r\n```\r\n
end_content = set "\r\n```\r\n"
end_content_len = length ${end_content}
help_end_pos = calc ${end_index} - ${end_content_len}

# Extract just the help content
readme_help = substring ${readme_content} ${help_start_pos} ${help_end_pos}
readme_help = trim ${readme_help}

# Write data to temporary files for use by calling tasks
writefile .readme-help.tmp ${readme_help}
writefile .readme-content.tmp ${readme_content}
writefile .positions.tmp "${start_index}\r\n${end_index}\r\n${help_start_pos}\r\n${help_end_pos}"
'''

[tasks.check-readme-help-task]
private = true
description = "Verify README help section matches current --help output"
dependencies = ["process-readme-help"]
script_runner = "@duckscript"
script = '''
# Read data from temporary files created by shared task
actual_help = readfile .help.tmp
readme_help = readfile .readme-help.tmp

result = eq ${actual_help} ${readme_help}

if not ${result}
    # ERROR tag in red, rest in default
    exec "powershell" "-Command" "Write-Host -NoNewline -ForegroundColor Red 'ERROR'; Write-Host ' - README.md help output is outdated!'"

    echo ""
    echo "Differences found:"
    echo "=================="

    # Use git diff to show only the differences with color
    # --no-pager disable the pager
    # --no-index allows diffing files outside git repo
    # --color=always forces color output even when not in terminal
    # --no-prefix removes a/ and b/ prefixes from filenames
    # -U3 shows 3 lines of context around changes
    # Redirect stderr to suppress line ending warnings
    exec "cmd" "/c" "git --no-pager diff --no-index --color=always --no-prefix -U3 .readme-help.tmp .help.tmp 2>nul"

    # ==> in yellow, rest in default
    exec "powershell" "-Command" "Write-Host -NoNewline -ForegroundColor Yellow '==>'; Write-Host ' Run ''cargo make update-readme-help'' to fix this.'"

    exit 1
else
    # INFO tag in green, rest in default
    exec "powershell" "-Command" "Write-Host -NoNewline -ForegroundColor Green 'INFO'; Write-Host ' - README.md help output is up to date.'"
end
'''

[tasks.update-readme-help]
# Task used to check whether the help section of the README.md matches the current `--help` output
# and update the README.md in case it doesn't.
# As the underlying task creates temporary files a cleanup task is defined to delete them afterwards.
description = "Update README.md help section with current --help output"
run_task = { name = [
    "update-readme-help-task",
], fork = true, cleanup_task = "process-readme-help-cleanup" }

[tasks.update-readme-help-task]
private = true
description = "Update README.md help section with current --help output"
dependencies = ["process-readme-help"]
script_runner = "@duckscript"
script = '''
# Read data from temporary files created by shared task
actual_help = readfile .help.tmp
readme_help = readfile .readme-help.tmp

result = eq ${actual_help} ${readme_help}

if ${result}
    exec "powershell" "-Command" "Write-Host -NoNewline -ForegroundColor Green 'INFO'; Write-Host ' - README.md help section is up to date, nothing to be done.'"
 exit 0
end

exec "powershell" "-Command" "Write-Host -NoNewline -ForegroundColor Yellow 'WARNING'; Write-Host ' - README.md help section is outdated - fixing it.'"

# Get processed data from shared task
readme_content = readfile .readme-content.tmp
positions = readfile .positions.tmp
position_lines = split ${positions} "\r\n"
start_index = array_get ${position_lines} 0
end_index = array_get ${position_lines} 1
help_start_pos = array_get ${position_lines} 2
help_end_pos = array_get ${position_lines} 3

# Build the new README content by replacing the help section
# Get content before the help section
before_help = substring ${readme_content} 0 ${help_start_pos}

# Get content after the help section
after_help = substring ${readme_content} ${help_end_pos}

# Combine: before + new help + after
new_readme_content = set "${before_help}${actual_help}${after_help}"

# Write the updated content back to README.md
writefile README.md ${new_readme_content}

# INFO tag in green, rest in default
exec "powershell" "-Command" "Write-Host -NoNewline -ForegroundColor Green 'INFO'; Write-Host ' - README.md help section has been updated with current --help output.'"

# This task is run by pre-commit git hooks and should abort
# a commit in case changes had to be made, thus we exit 1
exit 1
'''

##########################################################################
# ░█▀▄░█▀▀░█░░░█▀▀░█▀█░█▀▀░█▀▀░░░█▀█░█░█░▀█▀░█▀█░█▄█░█▀█░▀█▀░▀█▀░█▀█░█▀█ #
# ░█▀▄░█▀▀░█░░░█▀▀░█▀█░▀▀█░█▀▀░░░█▀█░█░█░░█░░█░█░█░█░█▀█░░█░░░█░░█░█░█░█ #
# ░▀░▀░▀▀▀░▀▀▀░▀▀▀░▀░▀░▀▀▀░▀▀▀░░░▀░▀░▀▀▀░░▀░░▀▀▀░▀░▀░▀░▀░░▀░░▀▀▀░▀▀▀░▀░▀ #
##########################################################################

[tasks.prepare-release]
description = "Prepare a new release by updating version, creating maintenance branch if needed, committing and pushing changes"
script_runner = "@rust"
script = '''
//! ```cargo
//! [dependencies]
//! semver = "1.0"
//! toml_edit = "0.21"
//! log = "0.4"
//! env_logger = "0.11"
//! ```

use std::process::{Command, exit};
use std::fs;
use std::io::{self, Write};
use semver::Version;
use log::{info, error};

#[derive(Debug, PartialEq)]
enum ReleaseType {
    Major,
    Minor,
    Patch,
}

impl std::fmt::Display for ReleaseType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ReleaseType::Major => write!(f, "major"),
            ReleaseType::Minor => write!(f, "minor"),
            ReleaseType::Patch => write!(f, "patch"),
        }
    }
}

fn main() {
    // Initialize logger with custom format: "LEVEL - message" with colors
    env_logger::Builder::from_default_env()
        .filter_level(log::LevelFilter::Info)
        .format_timestamp(None)
        .format_module_path(false)
        .format_target(false)
        .format(|buf, record| {
            use std::io::Write;
            let level_style = buf.default_level_style(record.level());
            writeln!(
                buf,
                "{level_style}{}{level_style:#} - {}",
                record.level(),
                record.args()
            )
        })
        .init();

    // Check if git working directory is clean
    let status_output = Command::new("git")
        .args(&["status", "--porcelain"])
        .output()
        .expect("Failed to check git status");

    if !status_output.stdout.is_empty() {
        error!("Git working directory is not clean. Please commit or stash changes first.");
        exit(1);
    }

    // Get current branch
    let branch_output = Command::new("git")
        .args(&["branch", "--show-current"])
        .output()
        .expect("Failed to get current branch");

    let current_branch = String::from_utf8(branch_output.stdout)
        .expect("Invalid UTF-8 in branch name")
        .trim()
        .to_string();

    info!("Current branch: {}", current_branch);

    let cargo_content = fs::read_to_string("Cargo.toml")
        .expect("Failed to read Cargo.toml");
    let cargo_doc = cargo_content.parse::<toml_edit::Document>()
        .expect("Failed to parse Cargo.toml");
    let current_version_str = cargo_doc["package"]["version"]
        .as_str()
        .expect("Failed to get version from Cargo.toml");

    let current_version = Version::parse(current_version_str)
        .expect("Failed to parse current version");

    info!("Current version: {}", current_version);

    // Determine suggested release type and calculate next version
    let (suggested_release_type, suggested_version) = if current_branch == "main" {
        // Minor release from main branch
        let mut next = current_version.clone();
        next.minor += 1;
        next.patch = 0;
        (ReleaseType::Minor, next)
    } else if current_branch.ends_with("-maintenance") {
        // Patch release from maintenance branch
        let mut next = current_version.clone();
        next.patch += 1;
        (ReleaseType::Patch, next)
    } else {
        error!("Must be on 'main' branch or a '*-maintenance' branch to prepare a release");
        eprintln!("       Current branch: {}", current_branch);
        exit(1);
    };

    // Ask user for confirmation and allow custom version
    print!("Preparing {} release: {} -> {}. Continue? [Y/n]: ",
           suggested_release_type, current_version, suggested_version);
    io::stdout().flush().unwrap();

    let mut input = String::new();
    io::stdin().read_line(&mut input).expect("Failed to read input");
    let input = input.trim().to_lowercase();

    let (next_version, actual_release_type) = if input == "n" || input == "no" {
        print!("Enter custom version (current: {}): ", current_version);
        io::stdout().flush().unwrap();

        let mut custom_version = String::new();
        io::stdin().read_line(&mut custom_version).expect("Failed to read input");
        let custom_version_str = custom_version.trim().to_string();

        if custom_version_str.is_empty() {
            error!("Version cannot be empty");
            exit(1);
        }

        // Parse and validate version using semver
        let custom_version = match Version::parse(&custom_version_str) {
            Ok(v) => v,
            Err(_) => {
                error!("Invalid version format. Use semantic versioning (e.g., 1.2.3)");
                exit(1);
            }
        };

        // Determine actual release type based on version comparison
        let release_type = determine_release_type(&current_version, &custom_version);
        (custom_version, release_type)
    } else if input.is_empty() || input == "y" || input == "yes" {
        (suggested_version, suggested_release_type)
    } else {
        error!("Invalid input. Please enter Y/n");
        exit(1);
    };

    // Calculate target branch
    let target_branch = if current_branch == "main" {
        format!("{}.{}-maintenance", next_version.major, next_version.minor)
    } else {
        current_branch.clone()
    };

    info!("Preparing {} release: {} -> {}", actual_release_type, current_version, next_version);
    info!("Target branch: {}", target_branch);

    // If we're on main, create and switch to maintenance branch
    if current_branch == "main" {
        info!("Creating maintenance branch: {}", target_branch);

        // Create maintenance branch
        let create_result = Command::new("git")
            .args(&["checkout", "-b", &target_branch])
            .status()
            .expect("Failed to create maintenance branch");

        if !create_result.success() {
            error!("Failed to create maintenance branch");
            exit(1);
        }
    }

    // Update version in Cargo.toml using toml_edit for format preservation
    info!("Updating Cargo.toml version to {}", next_version);
    let updated_cargo = update_version_in_toml_edit(cargo_doc, &next_version.to_string());
    fs::write("Cargo.toml", updated_cargo)
        .expect("Failed to write updated Cargo.toml");

    // Run cargo update --workspace to update Cargo.lock with new version
    info!("Updating Cargo.lock with new version");
    let update_result = Command::new("cargo")
        .args(&["update", "--workspace"])
        .status()
        .expect("Failed to run cargo update");

    if !update_result.success() {
        error!("Failed to update Cargo.lock - cargo update failed");
        exit(1);
    }

    // Generate changelog
    info!("Generating changelog");
    let changelog_result = Command::new("cargo")
        .args(&["make", "generate-changelog"])
        .status()
        .expect("Failed to run changelog generation");

    if !changelog_result.success() {
        error!("Failed to generate changelog");
        exit(1);
    }

    // Commit version change (including Cargo.toml, Cargo.lock, CHANGELOG.md and changelogging.toml)
    // NOTE: we expect here that the generate-changelog task did update the CHANGELOG.md and the changelogging.toml
    let commit_message = format!("Version {}", next_version);
    info!("Committing version change: {}", commit_message);

    let add_result = Command::new("git")
        .args(&["add", "Cargo.toml", "Cargo.lock", "CHANGELOG.md", "changelogging.toml"])
        .status()
        .expect("Failed to add files to git");

    if !add_result.success() {
        error!("Failed to add files to git");
        exit(1);
    }

    let commit_result = Command::new("git")
        .args(&["commit", "-m", &commit_message])
        .status()
        .expect("Failed to commit version change");

    if !commit_result.success() {
        error!("Failed to commit version change");
        exit(1);
    }

    // Push to remote
    info!("Pushing version commit to remote");
    let push_args = if current_branch == "main" {
        // Push new maintenance branch with upstream
        vec!["push", "-u", "origin", &target_branch]
    } else {
        // Push to existing branch
        vec!["push"]
    };

    let push_result = Command::new("git")
        .args(&push_args)
        .status()
        .expect("Failed to push to remote");

    if !push_result.success() {
        error!("Failed to push to remote");
        exit(1);
    }

    info!("Release {} prepared and pushed on branch {}", next_version, target_branch);
    info!("Run 'cargo make create-release-tag' to create and push the release tag");
}

fn determine_release_type(current: &Version, next: &Version) -> ReleaseType {
    if next.major > current.major {
        ReleaseType::Major
    } else if next.minor > current.minor {
        ReleaseType::Minor
    } else if next.patch > current.patch {
        ReleaseType::Patch
    } else {
        // Fallback for edge cases
        ReleaseType::Patch
    }
}

fn update_version_in_toml_edit(mut cargo_doc: toml_edit::Document, new_version: &str) -> String {
    // Update the version in the [package] section using toml_edit for format preservation
    cargo_doc["package"]["version"] = toml_edit::value(new_version);

    // Return the document as string - toml_edit preserves formatting
    cargo_doc.to_string()
}
'''

##################################################################################
# ░█▀▀░█░█░█▀█░█▀█░█▀▀░█▀▀░█░░░█▀█░█▀▀░░░█▄█░█▀█░█▀█░█▀█░█▀▀░█▀▀░█▄█░█▀▀░█▀█░▀█▀ #
# ░█░░░█▀█░█▀█░█░█░█░█░█▀▀░█░░░█░█░█░█░░░█░█░█▀█░█░█░█▀█░█░█░█▀▀░█░█░█▀▀░█░█░░█░ #
# ░▀▀▀░▀░▀░▀░▀░▀░▀░▀▀▀░▀▀▀░▀▀▀░▀▀▀░▀▀▀░░░▀░▀░▀░▀░▀░▀░▀░▀░▀▀▀░▀▀▀░▀░▀░▀▀▀░▀░▀░░▀░ #
##################################################################################

# Uses the current version, is only ment to be called from prepare-release
# after the next version has been calculated and configured.
[tasks.generate-changelog]
description = "Generate changelog from fragments and update release template"
script_runner = "@rust"
script = '''
//! ```cargo
//! [dependencies]
//! toml_edit = "0.21"
//! ```

use std::process::{Command, exit};
use std::fs;

fn main() {
    // Get current version from Cargo.toml
    let cargo_content = fs::read_to_string("Cargo.toml")
        .expect("Failed to read Cargo.toml");
    let cargo_doc = cargo_content.parse::<toml_edit::Document>()
        .expect("Failed to parse Cargo.toml");
    let current_version = cargo_doc["package"]["version"]
        .as_str()
        .expect("Failed to get version from Cargo.toml");

    println!("Generating changelog for version {}", current_version);

    // Update version in changelogging.toml
    let changelogging_content = fs::read_to_string("changelogging.toml")
        .expect("Failed to read changelogging.toml");
    let mut changelogging_doc = changelogging_content.parse::<toml_edit::Document>()
        .expect("Failed to parse changelogging.toml");

    changelogging_doc["context"]["version"] = toml_edit::value(current_version);
    fs::write("changelogging.toml", changelogging_doc.to_string())
        .expect("Failed to write changelogging.toml");

    // Run changelogging build to update CHANGELOG.md
    let build_result = Command::new("changelogging")
        .args(&["build", "--remove"])
        .status()
        .expect("Failed to run changelogging build");

    if !build_result.success() {
        eprintln!("Failed to build changelog");
        exit(1);
    }
}
'''

[tasks.release]
description = "Create and push an annotated git tag for the current release version, inturn triggering the release github workflow"
script_runner = "@rust"
script = '''
//! ```cargo
//! [dependencies]
//! semver = "1.0"
//! toml = "0.8"
//! log = "0.4"
//! env_logger = "0.11"
//! ```

use std::process::{Command, exit};
use std::fs;
use std::io::{self, Write};
use semver::Version;
use log::{info, warn, error};

fn main() {
    // Initialize logger with custom format: "LEVEL - message" with colors
    env_logger::Builder::from_default_env()
        .filter_level(log::LevelFilter::Info)
        .format_timestamp(None)
        .format_module_path(false)
        .format_target(false)
        .format(|buf, record| {
            use std::io::Write;
            let level_style = buf.default_level_style(record.level());
            writeln!(
                buf,
                "{level_style}{}{level_style:#} - {}",
                record.level(),
                record.args()
            )
        })
        .init();

    // Get current branch
    let branch_output = Command::new("git")
        .args(&["branch", "--show-current"])
        .output()
        .expect("Failed to get current branch");

    let current_branch = String::from_utf8(branch_output.stdout)
        .expect("Invalid UTF-8 in branch name")
        .trim()
        .to_string();

    // Verify we're on a maintenance branch
    if !current_branch.ends_with("-maintenance") {
        error!("Must be on a maintenance branch to create release tag");
        eprintln!("       Current branch: {}", current_branch);
        eprintln!("       Run 'cargo make prepare-release' first");
        exit(1);
    }

    // Read version from Cargo.toml using simple TOML parsing
    let cargo_content = fs::read_to_string("Cargo.toml")
        .expect("Failed to read Cargo.toml");

    let cargo_toml: toml::Value = toml::from_str(&cargo_content)
        .expect("Failed to parse Cargo.toml");

    let current_version_str = cargo_toml["package"]["version"]
        .as_str()
        .expect("Failed to get version from Cargo.toml");

    let version = Version::parse(current_version_str)
        .expect("Failed to parse version");

    info!("Current branch: {}", current_branch);
    info!("Version to tag: {}", version);

    // Check if tag already exists
    let tag_check = Command::new("git")
        .args(&["tag", "-l", &version.to_string()])
        .output()
        .expect("Failed to check existing tags");

    if !tag_check.stdout.is_empty() {
        error!("Tag {} already exists", version);
        exit(1);
    }

    // Verify the latest commit message matches the version
    let commit_msg_output = Command::new("git")
        .args(&["log", "-1", "--pretty=format:%s"])
        .output()
        .expect("Failed to get latest commit message");

    let commit_msg = String::from_utf8(commit_msg_output.stdout)
        .expect("Invalid UTF-8 in commit message")
        .trim()
        .to_string();

    let expected_msg = format!("Version {}", version);
    if commit_msg != expected_msg {
        error!("Latest commit message doesn't match expected version commit");
        eprintln!("       Expected: {}", expected_msg);
        eprintln!("       Actual: {}", commit_msg);
        eprintln!("       Run 'cargo make prepare-release' first");
        exit(1);
    }

    // Fetch latest changes to ensure we're up to date
    info!("Fetching latest changes from remote");
    let fetch_result = Command::new("git")
        .args(&["fetch"])
        .status()
        .expect("Failed to fetch from remote");

    if !fetch_result.success() {
        warn!("Failed to fetch from remote, continuing anyway");
    }

    // Check if we're behind remote
    let behind_check = Command::new("git")
        .args(&["rev-list", "--count", &format!("HEAD..origin/{}", current_branch)])
        .output()
        .expect("Failed to check if behind remote");

    let behind_count = String::from_utf8(behind_check.stdout)
        .expect("Invalid UTF-8 in behind count")
        .trim()
        .parse::<u32>()
        .unwrap_or(0);

    if behind_count > 0 {
        error!("Local branch is {} commits behind remote", behind_count);
        eprintln!("       Run 'git pull' to update");
        exit(1);
    }

    // Ask for user confirmation
    print!("About to create and push tag '{}' for release. Continue? [Y/n]: ", version);
    io::stdout().flush().unwrap();

    let mut input = String::new();
    io::stdin().read_line(&mut input).expect("Failed to read input");

    if input.trim().to_lowercase() != "y" {
        info!("Tag creation cancelled");
        exit(0);
    }

    // Create annotated tag
    let tag_message = format!("Version {}", version);
    info!("Creating annotated tag: {}", version);

    let tag_result = Command::new("git")
        .args(&["tag", "-a", &version.to_string(), "-m", &tag_message])
        .status()
        .expect("Failed to create tag");

    if !tag_result.success() {
        error!("Failed to create tag");
        exit(1);
    }

    // Push tag to remote
    info!("Pushing tag to remote");
    let push_result = Command::new("git")
        .args(&["push", "origin", &version.to_string()])
        .status()
        .expect("Failed to push tag");

    if !push_result.success() {
        error!("Failed to push tag to remote");
        exit(1);
    }

    info!("Tag '{}' created and pushed to remote", version);
    info!("GitHub Actions release workflow should now be triggered");
    info!("Check: https://github.com/whme/csshw/actions/workflows/release.yml");
}
'''
